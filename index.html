<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mobile Music Mixer — Upload, Record & Download</title>
  <style>
    :root{
      --bg:#f6fbff;
      --card:#ffffff;
      --accent:#6c63ff;
      --accent-2:#00c2a8;
      --muted:#7b8a99;
      --success:#28a745;
      --danger:#e74c3c;
      --glass: rgba(255,255,255,0.6);
    }
    *{box-sizing:border-box}
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; padding:20px; background:linear-gradient(180deg,var(--bg),#eaf3ff); color:#0b1320;}
    .container{max-width:900px;margin:0 auto}
    header{display:flex;gap:12px;align-items:center}
    h1{font-size:18px;margin:0}
    p.lead{margin:6px 0 18px;color:var(--muted);font-size:14px}

    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 6px 20px rgba(30,40,60,0.08);margin-bottom:16px}

    .upload-row{display:flex;gap:12px;flex-wrap:wrap}
    .file-input{flex:1}
    input[type=file]{display:none}
    .fake-file{display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:12px;border:1px dashed #d9e6f8;background:linear-gradient(180deg,#ffffff,#fbfdff);}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:0;background:var(--accent);color:white;font-weight:600;cursor:pointer}
    .btn.secondary{background:#f0f6ff;color:#123;color:border:none}
    .btn.ghost{background:transparent;border:1px solid rgba(11,19,32,0.06);color:var(--accent)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .status{font-size:13px;color:var(--muted);}

    .big{font-size:16px;padding:14px 18px}
    .recording{background:linear-gradient(90deg,#ff6b6b,#ff3b3b);box-shadow:0 6px 18px rgba(255,99,99,0.12)}

    .row{display:flex;gap:12px;align-items:center}
    .flex-1{flex:1}

    .meter{height:8px;background:linear-gradient(90deg,#e6f7f4,var(--glass));border-radius:8px;overflow:hidden}
    .meter > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent-2));}

    .small{font-size:13px;color:var(--muted)}

    footer{margin-top:18px;font-size:13px;color:var(--muted); text-align:center}

    @media (max-width:520px){
      body{padding:12px}
      .btn{padding:10px}
      header{gap:8px}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div style="width:56px;height:56px;border-radius:14px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700;">M</div>
      <div>
        <h1>Mobile Music Mixer</h1>
        <p class="lead">Upload a background track, record your voice while listening to it, then mix & download the final file — all in your browser.</p>
      </div>
    </header>

    <section class="card">
      <h3 style="margin:0 0 8px 0">1) Upload background music</h3>
      <div class="upload-row">
        <label class="file-input flex-1">
          <div class="fake-file" id="fakeFile">
            <span id="bgFilename">No file chosen</span>
            <div style="display:flex;gap:8px">
              <button class="btn" id="chooseBtn">Choose</button>
              <input id="bgInput" type="file" accept="audio/*">
            </div>
          </div>
        </label>
      </div>
      <div style="margin-top:12px" class="small">Supported: MP3, WAV, M4A, OGG. On iOS Safari prefer MP3 / M4A.</div>
    </section>

    <section class="card">
      <h3 style="margin:0 0 8px 0">2) Play background / Record your voice</h3>
      <div class="row" style="margin-bottom:10px">
        <audio id="bgAudio" controls style="width:100%;" preload="auto"></audio>
      </div>

      <div class="controls">
        <button class="btn" id="playBgBtn">Play background</button>
        <button class="btn ghost" id="stopBgBtn">Stop background</button>
        <button class="btn" id="recordBtn">Start Recording</button>
        <button class="btn secondary" id="stopRecBtn">Stop Recording</button>
      </div>
      <div style="margin-top:12px" class="row">
        <div class="flex-1">
          <div class="small">Recording status: <strong id="recStatus">idle</strong></div>
          <div class="meter" style="margin-top:8px"><i id="meterFill"></i></div>
        </div>
        <div style="width:110px;text-align:right" class="small">Duration: <span id="recTime">0:00</span></div>
      </div>
    </section>

    <section class="card">
      <h3 style="margin:0 0 8px 0">3) Preview & Download</h3>
      <div class="row" style="margin-bottom:12px">
        <button class="btn" id="mixBtn">Create final mix</button>
        <button class="btn ghost" id="playMixBtn">Play final mix</button>
        <a id="downloadLink" class="btn" style="display:none">Download mix</a>
      </div>
      <div class="small">After creating the mix you can preview it and download a WAV file containing both background + your recorded voice.</div>
      <div style="margin-top:12px" class="small">Note: On mobile browsers you might need to allow microphone access and interact (tap) before audio plays.</div>
      <audio id="mixAudio" controls style="width:100%;margin-top:12px"></audio>
    </section>

    <footer class="small">Built for mobile — tap buttons to allow audio. If recording doesn't start on iOS, make sure you use Safari (some browsers restrict getUserMedia).</footer>
  </div>

<script>
// Elements
const bgInput = document.getElementById('bgInput');
const bgFilename = document.getElementById('bgFilename');
const bgAudio = document.getElementById('bgAudio');
const chooseBtn = document.getElementById('chooseBtn');
const playBgBtn = document.getElementById('playBgBtn');
const stopBgBtn = document.getElementById('stopBgBtn');
const recordBtn = document.getElementById('recordBtn');
const stopRecBtn = document.getElementById('stopRecBtn');
const recStatus = document.getElementById('recStatus');
const recTime = document.getElementById('recTime');
const meterFill = document.getElementById('meterFill');
const mixBtn = document.getElementById('mixBtn');
const playMixBtn = document.getElementById('playMixBtn');
const mixAudio = document.getElementById('mixAudio');
const downloadLink = document.getElementById('downloadLink');

let bgFile = null;
let recordedBlob = null;
let mediaRecorder = null;
let recChunks = [];
let recStart = 0;
let recTimerInterval = null;
let audioContext = null;
let analyser = null;
let micStream = null;

chooseBtn.addEventListener('click', ()=> bgInput.click());
bgInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  bgFile = f;
  bgFilename.textContent = f.name;
  const url = URL.createObjectURL(f);
  bgAudio.src = url;
});

playBgBtn.addEventListener('click', ()=>{
  if(!bgFile){alert('Please choose a background audio file first.'); return}
  bgAudio.play();
});
stopBgBtn.addEventListener('click', ()=>{
  bgAudio.pause(); bgAudio.currentTime = 0;
});

// Setup recording
recordBtn.addEventListener('click', async ()=>{
  if(!bgFile){ if(!confirm('No background selected. Do you still want to record?')) return }
  try{
    await startRecording();
  }catch(err){
    alert('Could not start recording: ' + (err.message||err));
  }
});
stopRecBtn.addEventListener('click', ()=>{
  stopRecording();
});

async function startRecording(){
  // request microphone
  const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });
  micStream = stream;
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  // analyser for meter
  analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
  const source = audioContext.createMediaStreamSource(stream);
  source.connect(analyser);
  visualizeMeter();

  // MediaRecorder (use default mimeType supported by browser)
  mediaRecorder = new MediaRecorder(stream);
  recChunks = [];
  mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recChunks.push(e.data); };
  mediaRecorder.onstop = ()=>{
    recordedBlob = new Blob(recChunks, { type: recChunks[0]?.type || 'audio/webm' });
    recStatus.textContent = 'stopped';
    stopMeter();
    if(bgAudio && !bgAudio.paused){ bgAudio.pause(); }
    updateButtonsAfterStop();
  };

  // start background playback from beginning so user records in sync
  if(bgAudio && bgFile){
    try{ bgAudio.currentTime = 0; await bgAudio.play(); }catch(e){ console.warn('bg play issue', e); }
  }

  mediaRecorder.start();
  recStart = Date.now();
  recStatus.textContent = 'recording';
  startRecTimer();
  updateButtonsDuringRec();
}

function stopRecording(){
  if(mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
  if(bgAudio && !bgAudio.paused) { bgAudio.pause(); }
}

function updateButtonsDuringRec(){
  recordBtn.classList.add('recording');
}
function updateButtonsAfterStop(){
  recordBtn.classList.remove('recording');
}

function startRecTimer(){
  recTime.textContent = '0:00';
  recTimerInterval = setInterval(()=>{
    const s = Math.floor((Date.now()-recStart)/1000);
    recTime.textContent = Math.floor(s/60)+':' + String(s%60).padStart(2,'0');
  },300);
}
function stopRecTimer(){ clearInterval(recTimerInterval); recTimerInterval=null; }

let meterAnimationId = null;
function visualizeMeter(){
  function frame(){
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    const max = data.reduce((a,b)=>a>b?a:b,0);
    const pct = Math.min(100, Math.round((max/255)*100));
    meterFill.style.width = pct + '%';
    meterAnimationId = requestAnimationFrame(frame);
  }
  frame();
}
function stopMeter(){ if(meterAnimationId) cancelAnimationFrame(meterAnimationId); meterFill.style.width='0%'; stopRecTimer(); }

// Mix two audio buffers (background + recorded voice) using OfflineAudioContext
mixBtn.addEventListener('click', async ()=>{
  if(!bgFile) { alert('Please upload a background audio file before mixing.'); return; }
  if(!recordedBlob) { alert('No recording found — please record your voice first.'); return; }
  mixBtn.disabled = true; mixBtn.textContent = 'Mixing...';
  try{
    const mixBlob = await createFinalMix(bgFile, recordedBlob);
    const url = URL.createObjectURL(mixBlob);
    mixAudio.src = url;
    downloadLink.href = url;
    downloadLink.style.display = 'inline-flex';
    downloadLink.download = 'final_mix.wav';
    downloadLink.textContent = 'Download mix';
    playMixBtn.onclick = ()=> mixAudio.play();
    alert('Final mix created — you can preview and download it.');
  }catch(err){
    console.error(err);
    alert('Mixing failed: ' + (err.message||err));
  }
  mixBtn.disabled = false; mixBtn.textContent = 'Create final mix';
});

async function createFinalMix(bgFile, voiceBlob){
  // read files to array buffers
  const bgAB = await fileToArrayBuffer(bgFile);
  const voiceAB = await blobToArrayBuffer(voiceBlob);

  const baseCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(2, 44100*120, 44100); // 120s cap

  // decode both
  const decodeCtx = new (window.AudioContext || window.webkitAudioContext)();
  const bgBuf = await decodeCtx.decodeAudioData(bgAB.slice(0));
  const voiceBuf = await decodeCtx.decodeAudioData(voiceAB.slice(0));
  decodeCtx.close();

  const length = Math.max(bgBuf.length, voiceBuf.length);
  const sampleRate = Math.max(bgBuf.sampleRate, voiceBuf.sampleRate, 44100);
  const offline = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(Math.max(bgBuf.numberOfChannels, voiceBuf.numberOfChannels), length, sampleRate);

  // background source
  const bgSource = offline.createBufferSource();
  bgSource.buffer = bgBuf;
  const bgGain = offline.createGain(); bgGain.gain.value = 0.8; // background level
  bgSource.connect(bgGain).connect(offline.destination);

  // voice source
  const voiceSource = offline.createBufferSource();
  voiceSource.buffer = voiceBuf;
  const voiceGain = offline.createGain(); voiceGain.gain.value = 1.0; // voice level
  voiceSource.connect(voiceGain).connect(offline.destination);

  // start them both at 0 so they're aligned
  bgSource.start(0);
  voiceSource.start(0);

  const rendered = await offline.startRendering();
  // encode to WAV
  const wavBlob = encodeWAV(rendered);
  return wavBlob;
}

function fileToArrayBuffer(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsArrayBuffer(file); }); }
function blobToArrayBuffer(blob){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsArrayBuffer(blob); }); }

function encodeWAV (audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const format = 1; // PCM
  const bitDepth = 16;

  const samples = audioBuffer.length * numChannels;
  const blockAlign = numChannels * bitDepth/8;
  const buffer = new ArrayBuffer(44 + samples * (bitDepth/8));
  const view = new DataView(buffer);

  /* RIFF identifier */ writeString(view, 0, 'RIFF');
  /* file length */ view.setUint32(4, 36 + samples * (bitDepth/8), true);
  /* RIFF type */ writeString(view, 8, 'WAVE');
  /* format chunk identifier */ writeString(view, 12, 'fmt ');
  /* format chunk length */ view.setUint32(16, 16, true);
  /* sample format (raw) */ view.setUint16(20, format, true);
  /* channel count */ view.setUint16(22, numChannels, true);
  /* sample rate */ view.setUint32(24, sampleRate, true);
  /* byte rate (sampleRate * blockAlign) */ view.setUint32(28, sampleRate * blockAlign, true);
  /* block align (channel count * bytes per sample) */ view.setUint16(32, blockAlign, true);
  /* bits per sample */ view.setUint16(34, bitDepth, true);
  /* data chunk identifier */ writeString(view, 36, 'data');
  /* data chunk length */ view.setUint32(40, samples * (bitDepth/8), true);

  // write interleaved PCM samples
  let offset = 44;
  const channelData = [];
  for (let ch = 0; ch < numChannels; ch++) channelData.push(audioBuffer.getChannelData(ch));

  for (let i = 0; i < audioBuffer.length; i++){
    for (let ch = 0; ch < numChannels; ch++){
      let sample = channelData[ch][i];
      // clamp
      sample = Math.max(-1, Math.min(1, sample));
      // convert to 16-bit PCM
      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      offset += 2;
    }
  }

  return new Blob([view], { type: 'audio/wav' });
}

function writeString(view, offset, string){ for (let i = 0; i < string.length; i++){ view.setUint8(offset + i, string.charCodeAt(i)); } }

// cleanup on page hide
window.addEventListener('pagehide', ()=>{
  if(audioContext) audioContext.close();
  if(micStream) micStream.getTracks().forEach(t=>t.stop());
});
</script>
</body>
</html>
